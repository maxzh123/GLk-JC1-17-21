package main.java;

public class Sample6 {//Сообщаем компилятору что Это класс и мы дали ему имя Sample6
    private static int count = 0;

    /* Это зарезервированное имя. функция класса с таким именем и параметрами, может быть вызвана из вне JVM, т.е являться точкой входа
     * */
    public static void main(String[] arg) { //Сообщаем компилятору что класс имеет публичный метод, не возвращающий рельтатов, но принимающий в качестве аргументов масив строк.
        for (int i = 1; i <= 1000; i++) {//для цулочисленного i установить значение 1;выполнять блок пока i меньше 100; после каждого исполнения увеличить i на 1
            if (isPrime(i)) {// Вызываем функцию которая проверит является ли число простым если да - выводим его
                System.out.println(i);//Достаем системный поток out и вызываем его метод println (напечатать и перевести строку). В качестве аргумента передаем то, что хотим напечатать.
            }//блока иначе нет. эта ситуация будет проигнорирована. никаких действий не выполнится.
        }
        System.out.println("Произвели сравнений остатка от деления:" + count);//Достаем системный поток out и вызываем его метод println (напечатать и перевести строку). В качестве аргумента передаем то, что хотим напечатать.
    }

    private static boolean isPrime(int i) {
        for (int f = 2; f < i; f++) { // для целочисленного f устанавливаю значение 2, выполняю блок пока f меньше i, после кажого выполнения значение f увеличивается на 1
            if (isFactor(f, i)) //вызывается метод ниже
                return false; // если доходит до этого, то число не подходит под наш критерий
            count++;
        }
        return true; //если доходит до этого, то число простое
    }
    private static boolean isFactor(int f, int i) {  //создается метод, который проверяет делится ли число i на f без остатка (вся суть метода в том чтобы перебирать сначала значение i, и вместе с этим значение f, пока не получится простое число, например i=5 и начинается перебор значений f:сначала 2-не делится без остатка, потом 3-не делится, потом 4-не делится следовательно число простое и так далее)
        // Я просто добавил подсчет чтобы стало видно, что метод хуже чем было изначально.
        count++;
        return i % f == 0;
    }
}
